\documentclass[a4paper,11pt]{article}

\usepackage{graphicx, url}

\newcounter{reqc}
\setcounter{reqc}{0}
\providecommand{\req}[3][req-\arabic{reqc}]{
	\refstepcounter{reqc}%
	\label{#1}%
	\noindent\textbf{Req \arabic{reqc}} %
	#3\\*%
}

%--Title---------
\title{Software Evolution - Assignment 2 : Architecture Reconstruction}
\author{Stef van Schuylenburg (0744314) \& Jules Wulms (0747580)}
\date{\today}
%----------------

\begin{document}

	\maketitle

	\section{Introduction}
		In this assignment we are going to reconstruct the architecture of a java program.
		To show the architecture we will create a UML class diagram containing the classes, fields, methods and relations between the classes.
		We create this diagram by first extracting the information from the java program using a program written in Rascal\cite{rascal}.
		Then we use this information to construct the classes, the fields and methods of the classes and the relations between the classes.
		In order to find all the relations we also use an Object Flow Graph, this graphs shows us where objects are used, and thus what class of objects are used by a class. %todo: zin loopt niet lekker
		In the end we also visualize the UML. For the visualization we use Rascal to generate a DOT file of the class diagram, this DOT file is then read by GraphViz\cite{graphviz} to draw a pdf image containing the diagram.
		
		In the assignment we will look at the input and output of our tool chain. 
		We will look at how the tool chain is created and how it should be used.
		We apply the tool chain to a java program and we also show the Object Flow Graph used in our tool chain to created the class diagram.
		We apply our tool chain to two version of a java program and compare the differences in the versions.
		And finally we will hold a discussion about our tool chain.
	
	\section{Input and Output}
		The general approach of our tool chain is that we take a java program as input and give a UML class diagram of this java program as output.
		In this section we look at the input and output in more detail to indicate what our tool chain exactly accepts and what it exaclty returns.
		
	\subsection{Input}
		We support the following features of the Java language:
		\begin{itemize}
			\item non-nested Classes: Classes are the main components of the UML Class diagram so, should have to be included to make the class diagrams.
			\item methods: The methods show the main functionality of a class and are used to find dependencies between classes.
			\item fields: The fields are used to create the associations and are used in the class description.
			\item generics: Generics are used to define the structure of a class or method, so we also have to include those. %TODO: maybe more explanation here
			\item inner classes: It is possible that classes depend on innner classes of other classes. So without the inner classes we are not able to create a complete class diagram.
			\item visibility: Visibility is not really important, but we include it because represents the scope of functions and thus also the functionality of class.
			\item static: Static fields and methods are not attributes of instances of a class, but can be used by all instances. So we have to show what is static, such that it is clear that all instances may depend on each other (as they use the same functions).
			\item extends and implements relation: The extends and implements relations is used to create the generalization and realization relations of the class diagram. Those relations are very important for the architectural structure.
			
		
		\end{itemize}
		
		We do not use the following features of the Java language:
		\begin{itemize}
			\item annotations: In Java annotations can be defined by any library or by the program itself, so supporting annotations would require an additional system to keep track of all the annotations. To make things not to complex, the annotations are not used in our tool chain.
			\item a number of modifiers: A number of modifiers like synchronized, volatile, native are not used in our system.
			We did not include those, because the modifiers are not often used and because they do not add usefull information for the architecture; most modifiers are about the implementation of the method or usage of a field.
		\end{itemize}
		
	\subsection{Output}
		The output of our tool chain is the class diagram.
		We did include the following features of a class diagram:
		\begin{itemize}
			\item classes: The basic component of the class diagram, included to show what classes are part of the program.
			\item fields and methods: Those are included to show the functionality of a class. We also decided to include the private fields and methods, because they explain the associations and dependencies.
			\item associations, dependencies, generalization and realization: Used to show the structure of our system.
			\item ``named associations'': Our associations are named in such a way that the name of the field is also used for the association. This makes it clears what the association represents and makes it also possible to have multiple association from one class going to the same class.
			\item inner classes: It is possible that classes depend on innner classes of other classes. So without the inner classes we are not able to create a complete class diagram. %todo the same as for input?
		\end{itemize}
		
		The following features are not included in our output:
		\begin{itemize}
			\item two-directional associations: We did not include those, because we prefer to use two one-directional associations. The one-directional associations do not have the problem where sometimes it is misunderstood whether the name belongs to one class or to the other. Also the associations are still clear when we only use the one-directional associations.
			\item multiplicity: We did not include the multiplicity, because when we extract the multiplicity from a program, we can only find $0..1$ and $0..*$.
			Only those two are found, because an association is either created from a collection ($0..*$) or a simple field($0..1$).
			We can easy find in our diagram which is the case by looking at the type, so adding the multiplicity would not make the diagram more clear.
		\end{itemize}
		
	\section{The Tool Chain}
	For our tool chain we use two different programs to execute it: We use Rascal and GraphViz.
	The main part of our tool chain is our program written in Rascal.
	
	\subsection{Rascal Program}
	
	We have divided our program in 3 components: \emph{Extraction, OFG} and \emph{Visualize}, those components are Rascal modules and Extraction and Visualize can be used in isolation. 
	Besides those components we also have two other modules: \emph{DiagramLanguage} and \emph{Main}.
	DiagramLanguage defines the datatypes that is used to transfer the diagram from Extraction to Visualize and Main is used to execute everything.
	
	The Extraction module has functions to extract a diagram (as defined by the DiagramLanguage) from a Java project. The module depends on the OFG module.
	The Extraction module uses the Java-extraction libraries from Rascal (found in the modules \texttt{\url{lang::java::jdt::m3::AST}} and \texttt{\url{lang::java::jdt::m3::Core}} to extract the classes, fields, methods and a number of relations from the java program and to construct the Diagram with it.
	It also uses the OFG module to find associations that can not be found using standard extraction of the java program.
	The main method that is used to generate the Diagram using the Extraction module is called \texttt{onsDiagram(M3 m)}.
	
	The OFG module is a module to create an Object Flow Graph and to get the relations from this Object Flow Graph which represent the association found using the Object Flow Graph.
	The Object Flow Graph uses the \emph{Rascal-OFG}\cite{rascal-ofg} to create the Object Flow Graph.
	After creating the Object Flow Graph the module uses this graph to create the associations which are used by the Extraction module.
	The main method, which is used to find the associations can be found at \texttt{cacl(bool forward)}.
	
	The Visualize module creates a string formatted in the DOT language which is used to render the diagram.
	This module takes a diagram as input and uses code generation to create a DOT file.
	The DOT file is intended to be used by GraphViz to create an image describing the diagram as a UML Class Diagram.
	The main method, which takes a diagram and creates the DOT file for it is called \texttt{diagram2dot(Diagram diagram)}.
	
	We decided to use those components and to decouple Extract and Visualize, such that we can easily use a different kind of visualization or a different kind of extraction.
	It also allows us to work seperated on those components and to rarely have to change one component because the other has changed.
	It also made testing easier. For example we did not had to create the diagram object (which can take quite some time) in order to test the Visualize module.
	
	Instead of using this style where another module (the Main module) uses the components to pass the return value of one
	to the other (like the pipe and filters style) we could also let Visualize depend on Extraction or vice versa.
	We decide to not do this, because this makes it easier to replace one of the components by something else.
	
	\subsection{GraphViz}
	
	To create an image of the diagram we use GraphViz.
	We use the DOT code generated by the Visualize module of our program.
	The GraphViz tools takes this DOT code as input and returns an image as output.
	
	\subsection{Usage of the Tool Chain}
	To use the Tool Chain we have created a Main module.
	This Main module contains a function called \texttt{run(loc project, loc file)}.
	Which creates DOT output for the eclipse program specified in \texttt{project}.
	(\texttt{project} is a Rascal location, so if you want to use for example the eclipse program eLib, then
	\texttt{project} would be \texttt{|project:///eLib|}.)
	After calling the run function DOT output for the diagram will be saved in \texttt{file}.
	Now we need GraphViz to generate the image.
	
	Assuming that GraphViz is installed the image can be generated with the following command:
	``\texttt{dot -Tps in.dot -o out.pdf}'' with \texttt{in.dot} being the location of the dot file and \texttt{out.dot}
	being the location where you want to save the image of the class diagram.
	
	
	
	\section{Application of Tool Chain}
		
		\subsection{eLib}
			
			
		\subsection{Case study: CyberNeko HTML Parser}
			
	
	\section{Discussion of Tool Chain}
	
	
	\section{Conclusions}
		
		\subsection{Requirement quality}
			

		\subsection{Dependencies}
			

		\subsection{Dependency graph}
		

		\subsection{Implications for evolution}


	\section{Threats to validity}


	\begin{thebibliography}{9}
		\bibitem{rascal}
			Rascal, Centrum Wiskunde \& Informatica , http://www.rascal-mpl.org/

		\bibitem{graphviz}
			GraphViz, Graph visualization software, http://www.graphviz.org/
			
		\bibitem{rascal-ofg}
			Rascal OFG, Davy Landman, https://github.com/cwi-swat/rascal-OFG

	\end{thebibliography}

\end{document}